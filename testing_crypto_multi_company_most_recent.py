# -*- coding: utf-8 -*-
"""Testing Crypto -  multi-company most recent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qAasIb3fXIqo7AxlPEo7sKDSFJTWOaIa
"""

from matplotlib.ticker import MaxNLocator

"""Install pysentimiento, which has BERTweet, a model that's used to evaluate the comments' sentiments"""

from google.colab import drive
drive.mount('/content/drive')

# Commented out IPython magic to ensure Python compatibility.
# # hides the cell output:
# %%capture cell
# !pip install pysentimiento

"""Load the wsb_comments csv from drive"""

# import numpy as np
# import pandas as pd
# import numbers
# # replace with the location in your drive
# df1 = pd.read_csv("/content/drive/My Drive/Sentiment Phase 2/Data Processing/Processed_CryptoCurrency_comments_1.csv")
# df2 = pd.read_csv("/content/drive/My Drive/Sentiment Phase 2/Data Processing/Processed_CryptoCurrency_comments_2.csv")
# df3 = pd.read_csv("/content/drive/My Drive/Sentiment Phase 2/Data Processing/Processed_CryptoCurrency_comments_3.csv")
# df4 = pd.read_csv("/content/drive/My Drive/Sentiment Phase 2/Data Processing/Processed_CryptoCurrency_comments_4.csv")
# df5 = pd.read_csv("/content/drive/My Drive/Sentiment Phase 2/Data Processing/Processed_CryptoCurrency_comments_5.csv")
# df6 = pd.read_csv("/content/drive/My Drive/Sentiment Phase 2/Data Processing/Processed_CryptoCurrency_comments_6.csv")

import numpy as np
import pandas as pd
import numbers
test = pd.read_csv("/content/drive/My Drive/Sentiment Phase 2/incomplete/testing_quality_comments_only.csv")

# #filter here
# #test = test[(test["Upvotes"] >= 3) | (test["count"] >= 200)]
# filtered = test[test["Upvotes"] >= 10]
# df = filtered.copy()

df = test.drop('count', axis=1)

df

# df = pd.concat([df1, df2, df3, df4, df5, df6], axis=0, ignore_index=True)
# df.head()

df.iloc[6]["Comment Link"]

"""Since the sentiments for every comment in wsb_comments.csv has already been evaluated beforehand by the model and saved in a google drive, obtain each of those sentiments and place them all in a single list

1. Download all of the stock data from 2014 to 2023, inclusive, for each of the 10 main companies
2. Create a function that finds the closing stock price for every single one of those companies for every single one of the days, when inputted a specific year
"""

import yfinance as yf

def download_stock_data(tickers, start_date, end_date):
    stock_data = {}
    for ticker in tickers:
        stock = yf.download(ticker, start=start_date, end=end_date,progress = False)
        stock_data[ticker] = stock

    #NONE will be a stock with infinite volume with 1 share costing 1 dollar
    stock_data["NONE"] = pd.DataFrame(stock_data[list(stock_data.keys())[0]]).map(lambda x: 1 if isinstance(x, (int, float)) else x)
    stock_data["NONE"].columns = list((column_tuple[0],"NONE") for column_tuple in stock_data["NONE"].columns)#[('Adj Close', 'NONE'), ('Close', 'NONE'), ('High', 'NONE'), ('Low', NONE), (Open, NONE), (Volume, NONE)]
    return stock_data

tickers = ["BTC-USD", "ETH-USD", "ADA-USD", "XRP-USD", "SOL-USD", "BNB-USD", "DOGE-USD"]

days_in_month = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
month2days = {i+1: days_in_month[i] for i in range(12)}

def simulate_investment_weekly(stock_data, investment_year):
    start_each = []
    end_each = []
    all_dates = []
    the_day = 1
    the_month = 1
    for i in range(365):
      start_dict = {ticket: 0 for ticket in tickers}
      general_dict = {ticket: 0 for ticket in tickers}

      for ticker, data in stock_data.items():
          try:
            """
            start_price = data[(data.index.year == investment_year) & (data.index.month == the_month) &
                                  (data.index.day == the_day)].iloc[-1]['Open']
            """
            final_price = data[(data.index.year == investment_year) & (data.index.month == the_month) &
                                  (data.index.day == the_day)].iloc[-1]['Close']
            #start_dict[ticker] = start_price
            general_dict[ticker] = final_price
          except:
            break

      all_dates.append(f"{the_month}/{the_day}")
      #start_each.append(start_dict)
      end_each.append(general_dict)

      the_day += 1
      if the_day > month2days[the_month]:
        the_day = 1
        the_month += 1
      if the_month > 12:
        break

    return {a:e for a, e in zip(all_dates, end_each)}
    #return {a:e for a, e in zip(all_dates, start_each)}, {a:e for a, e in zip(all_dates, end_each)}

start_date = '2014-01-01'
end_date = '2024-12-31'

stock_data = download_stock_data(tickers, start_date, end_date)

df = df.dropna()

"""Use the "Date" column to make "Year", "Month", and "Day" columns"""

df["Year"] = df["Date"].apply(lambda d: int(d.split("-")[0]))
df["Month"] = df["Date"].apply(lambda d: int(d.split("-")[1]))
df["Day"] = df["Date"].apply(lambda d: int(d.split("-")[2]))

"""Create a function that, given a particular year, can return two dictionaries:

1. dat2positive: Given a particular day in a year, returns another dictionary of the average sentiment for each of the 10 companies
2. dat2number: Similar as dat2positive, but returns a dictionary of the number of comments for each of the 10 companies
"""

df.columns = ["Upvotes", "Date", "User", "Comment Link", "Body", "Bitcoin", "Ethereum", "Cardano", "Ripple", "Solana", "Binance", "Dogecoin", "Pos", "Year", "Month", "Day"]

temp_df = df.copy()

#df= temp_df.copy()

def get_positive_number(end_week, YEAR):
  all_dates = list(end_week.keys())
  month_day = [[int(d.split("/")[0]), int(d.split("/")[1])] for d in all_dates]
  c_names = ["Bitcoin", "Ethereum", "Cardano", "Ripple", "Solana", "Binance", "Dogecoin"]

  dat2positive = {}
  dat2number = {}
  for m_d in month_day:
    df_specific = df[(df["Year"] == YEAR) & (df["Month"] == m_d[0]) & (df["Day"] == m_d[1])]
    company2pos = {ticker: 0 for ticker in tickers}
    company2num = {ticker: 0 for ticker in tickers}

    company2pos["None"] = 0
    company2num["None"] = 0

    for i in range(len(c_names)):
      df_company = df_specific[df_specific[c_names[i]] == "Yes"]
      if df_company.shape[0] > 0:
        company2pos[tickers[i]] = df_company["Pos"].mean()
      company2num[tickers[i]] = df_company.shape[0]

    dat2positive[f"{m_d[0]}/{m_d[1]}"] = company2pos
    dat2number[f"{m_d[0]}/{m_d[1]}"] = company2num

  return dat2positive, dat2number

#start_week, end_week = simulate_investment_weekly(stock_data, THE_YEAR)
#end_week = simulate_investment_weekly(stock_data, THE_YEAR)
#print(get_positive_number(end_week, THE_YEAR))

"""get our data for running the simulation"""

THE_YEAR = 2021
end_week = simulate_investment_weekly(stock_data, THE_YEAR)

dat2positive, dat2number = get_positive_number(end_week, THE_YEAR)
all_dates = list(end_week.keys())

'''
MAIN DRIVER
'''


import matplotlib.pyplot as plt
from matplotlib import cm
from matplotlib.colors import Normalize
import seaborn as sns

FACTOR = 0.7

UPPER = 0
LOWER = -0

# higher = less impulsive
num_to_remember = 1





def money_growth(companies:list, upper_bound = None, lower_bound = None,print_error = True, num_to_remember = 1, power = 1):
  for key in end_week.keys():
    end_week[key] = dict(end_week[key])
    for key2 in end_week[key].keys():

        end_week[key][key2] = float(end_week[key][key2])

  portfolio = dict()
  for name in companies:
    portfolio[name] = 100/len(companies)

  date_start_index = 4
  if THE_YEAR == 2020: date_start_index = 2

  cmap = cm.seismic
  norm = Normalize(vmin=-0.1, vmax=0.1)

  stock_values = {};

  the_dates = []
  stock_values = dict()
  investment_log = dict()
  percent_investment_log = dict()
  relevances = dict()
  lastX = dict()
  for name in companies:
    lastX[name] = []
    investment_log[name] = []
    percent_investment_log[name] = []
    stock_values[name] = []

  store_yest = 0

  investment_reallocation_error = 0

  monthly_changes = []

  prev_price = {}
  for name in companies:
    prev_price[name] = 0

  while date_start_index < 364:
    capital = sum(list(portfolio.values()))
    for stock in companies:
        investment_log[stock].append(portfolio[stock]);
        percent_investment_log[stock].append(portfolio[stock]/capital)

    today_date = all_dates[date_start_index] #Date for today(End of today)
    yest_date = all_dates[date_start_index-1] #Date for yesterday(start of today)

    if int(today_date.split("/")[0]) != int(yest_date.split("/")[0]):
      monthly_changes.append(sum(list(portfolio.values())))


    pct_growth_pos = dict()
    change_comments = dict()
    volume_growth = dict()
    pos_yest = dict()
    pos_tod = dict()
    comm_yest = dict()
    comm_tod = dict()
    stock_start = dict()
    stock_end = dict()
    pct_growth = dict()
    the_dates.append(today_date)

    if end_week[today_date][companies[0]] == 0: #If the stock market was not open this day
        date_start_index += 1 #Increase the date
        for stock in companies:
            try:
                stock_values[stock].append(stock_values[stock][-1])
            except:
                stock_values[stock].append(1)
        continue
    else:
        for stock in companies:
            stock_values[stock].append(end_week[today_date][stock])

    for stock in companies:


        # stock_start[stock] = end_week[yest_date][stock]
        # if store_yest == 0:
        #     store_yest = yest_date #Store the most previous day where the stock was open
        #     stock_start[stock] = end_week[yest_date][stock]
        # else:
        #     #Get the most recent previous stock value
        #     store_yest = yest_date
        #     stock_start[stock] = end_week[yest_date][stock]
        #     if store_yest != 0:
        #         stock_start[stock] = end_week[store_yest][stock]
        # #Get the stock value at the end of today, and update money_stock accordingly

        stock_end[stock ]= end_week[today_date][stock]
        if prev_price[stock] == 0:
            pct_growth[stock] = 1
        else:
            pct_growth[stock] = (stock_end[stock]) / prev_price[stock]
        #portfolio[stock] += portfolio[stock] * pct_growth[stock]
        portfolio[stock] *= (pct_growth[stock])
        if stock_end[stock] != 0:
            prev_price[stock] = stock_end[stock]

        #Use dat2positive and dat2number to calculate the sentiment volume growth for today
        pos_yest[stock] = dat2positive[yest_date][stock]
        pos_tod[stock] = dat2positive[today_date][stock]
        comm_yest[stock] = dat2number[yest_date][stock]
        comm_tod[stock ]= dat2number[today_date][stock]

        pct_growth_pos[stock] = pos_tod[stock] - pos_yest[stock]
        #for some reason the original logic "likes" a decrease in comments
        change_comments[stock] = comm_tod[stock] - comm_yest[stock] # mabye put back absolute value
        volume_growth[stock] = pct_growth_pos[stock] * change_comments[stock] # was times






    if lower_bound != None and upper_bound != None: #and len(valid) > 1:

        '''
        IMPLEMENT SENTIMENT STRATEGIES HERE BY EDITING THE PORTFOLIO DICTIONARY
        '''

        for stock in companies:
            if stock not in volume_growth.keys():
                continue
            lastX[stock].append(volume_growth[stock] * abs((volume_growth[stock] ** (power - 1))))
            while len(lastX[stock]) > num_to_remember:
                lastX[stock].pop(0)
        valid = []
        for stock in companies:
            if np.mean(lastX[stock]) > upper_bound or np.mean(lastX[stock]) < lower_bound:
                valid.append(stock)



        if (len(valid) == 0):
            date_start_index += 1
            continue


        min_volume_growth = 10e1000000
        for stock in valid:
            if np.mean(lastX[stock]) < min_volume_growth:
                min_volume_growth = np.mean(lastX[stock])

        all_same = True
        for stock in valid:
            if np.mean(lastX[stock]) != min_volume_growth:
                all_same = False
                break;

        if all_same:
            date_start_index += 1
            continue

        capital = 0
        for stock in companies:
            capital += portfolio[stock]


        for stock in companies:
            portfolio[stock] = 0

        sum_growth = 0
        for stock in valid:
            sum_growth += np.mean(lastX[stock]) - min_volume_growth

        sum_portfolio_before = sum(list(portfolio.values()))

        for stock in valid:
            if sum_growth != 0:
                portfolio[stock] = capital * (np.mean(lastX[stock]) - min_volume_growth) / sum_growth

        sum_portfolio_after = sum(list(portfolio.values()))

        error = sum_portfolio_before - sum_portfolio_after
        investment_reallocation_error += error
        #if sum_portfolio_before != sum_portfolio_after: raise Exception(f"illegal value increase: {sum_portfolio_before} to {sum_portfolio_after}")



    #Increase the date
    store_yest = 0
    date_start_index += 1

    # monthly_changes.append(sum(list(portfolio.values())))
  if print_error:
    print(f'total investment algorithm error: {investment_reallocation_error}')
  return (portfolio, stock_values, investment_log, the_dates, monthly_changes, percent_investment_log)

BINS = 100
def graph_distributions():
    portfolio, stock_values, investment_log, the_dates, monthly_changes, percent_investment_log = money_growth(["BTC-USD", "ETH-USD", "ADA-USD", "XRP-USD", "SOL-USD", "BNB-USD", "DOGE-USD"],0,0,False,1)
    print(list(sum(ls) for ls in percent_investment_log.values()))
    print(stock_values)
    sns.barplot(dict(zip((list(tickers[i] for i in range(0,7))),list(np.mean(ls)* 100 for ls in percent_investment_log.values()))))
    print(np.std(list(np.mean(ls)* 100 for ls in percent_investment_log.values())))
    overall_stock_change = {}
    for (stock, values) in stock_values.items():

        overall_stock_change[stock] = 100 * values[-1] / values[1] - 100;
    plt.figure(figsize=(9,6))
    plt.show()
    sns.barplot(overall_stock_change)
    plt.figure(figsize=(9,6))
    plt.show()
    plt.scatter(range(len(monthly_changes)),monthly_changes);
    plt.show();

    portfolio, stock_values, investment_log, the_dates, monthly_changes, percent_investment_log = money_growth(["BTC-USD", "ETH-USD", "ADA-USD", "XRP-USD", "SOL-USD", "BNB-USD", "DOGE-USD"],0,0,False,1)

    # Calculate values for the first plot (average percentage invested)
    avg_percentage_invested = list(np.mean(ls) for ls in percent_investment_log.values())

    # Calculate values for the second plot (overall stock change)
    overall_stock_change = {}
    for stock, values in stock_values.items():
        overall_stock_change[stock] = 100 * values[-1] / values[1] - 100

    print(sum(list(overall_stock_change.values()))/10)

    # Multiply values from the two plots
    multiplied_values = [avg_percentage_invested[i] * list(overall_stock_change.values())[i] for i in range(len(avg_percentage_invested))]
    print(multiplied_values)

    # Create the third plot
    plt.figure(figsize=(9, 6))
    sns.barplot(x=list(tickers[i] for i in range(0, 7)), y=multiplied_values)
    # sns.barplot(x=tickers, y=multiplied_values)
    plt.title("Multiplied Values of Average Percentage Invested and Overall Stock Change")
    plt.xlabel("Companies")
    plt.ylabel("Multiplied Values")
    plt.show()
    print(sum(multiplied_values))



    # Assuming investment_log is already defined

    # Calculate total portfolio value at each time step
    portfolio_values = [sum(values) for values in zip(*investment_log.values())]

    # Calculate portfolio increases
    portfolio_increases = [(100 * (portfolio_values[i] / portfolio_values[i-1] - 1))
                        for i in range(1, len(portfolio_values)) if portfolio_values[i] != portfolio_values[i - 1]]

    mean_increase = np.mean(portfolio_increases)
    std_increase = np.std(portfolio_increases)

    # Create the histogram
    plt.hist(portfolio_increases, bins=BINS)
    plt.xlabel("Portfolio Increase")
    plt.ylabel("Frequency")
    plt.title("Distribution of Portfolio Increases Over Time")

    plt.axvline(mean_increase, color='r', linestyle='--', label=f'Mean: {mean_increase:.2f}%')
    plt.axvline(mean_increase + std_increase, color='g', linestyle='--', label=f'Std Dev: {std_increase:.2f}%')
    plt.axvline(mean_increase - std_increase, color='g', linestyle='--')
    plt.legend()
    plt.show()




    # Calculate total portfolio value at each time step
    stock_values = [sum(values) for values in zip(*stock_values.values())]

    # Calculate portfolio increases
    stock_increases = [(100 * (stock_values[i] / stock_values[i-1] - 1))
                        for i in range(1, len(stock_values)) if stock_values[i] != stock_values[i - 1]]

    mean_increase = np.mean(stock_increases)
    std_increase = np.std(stock_increases)


    # Create the histogram
    plt.hist(stock_increases, bins=BINS)
    plt.xlabel("Stock Increase")
    plt.ylabel("Frequency")
    plt.title("Distribution of Stock Increases Over Time")


    plt.axvline(mean_increase, color='r', linestyle='--', label=f'Mean: {mean_increase:.2f}%')
    plt.axvline(mean_increase + std_increase, color='g', linestyle='--', label=f'Std Dev: {std_increase:.2f}%')
    plt.axvline(mean_increase - std_increase, color='g', linestyle='--')
    plt.legend()
    plt.show()

    # Calculate difference between portfolio and stock increases
    diff_increases = [portfolio_increases[i] - stock_increases[i]
                      for i in range(min(len(portfolio_increases), len(stock_increases)))]

    mean_diff = np.mean(diff_increases)
    std_diff = np.std(diff_increases)

    # Create the histogram for the difference
    plt.hist(diff_increases, bins=BINS)
    plt.xlabel("Difference in Increase (Portfolio - Stock)")
    plt.ylabel("Frequency")
    plt.title("Distribution of Difference in Increases Over Time")

    plt.axvline(mean_diff, color='r', linestyle='--', label=f'Mean: {mean_diff:.2f}%')
    plt.axvline(mean_diff + std_diff, color='g', linestyle='--', label=f'Std Dev: {std_diff:.2f}%')
    plt.axvline(mean_diff - std_diff, color='g', linestyle='--')
    plt.legend()
    plt.show()






graph_distributions()

def permute(values:list):
    permutations = []
    for i in range(pow(2,len(values))):
        permutation = []
        for j, obj in enumerate(values):
            if int(i / (pow(2,j))) % 2 == 1:
                permutation.append(obj)
        permutations.append(permutation)
    return permutations

'''
GRAPHING
'''
def calculate_values(cur_tickers, UPPER = 0, LOWER = 0, num_to_remember = 1, power = 1, print_error = False):
    sum_monthly_changes = [0 for i in range(13)]

    normal = money_growth(cur_tickers,print_error = print_error) #Bounds make sure no changes occur
    alg = money_growth(cur_tickers, UPPER, LOWER, num_to_remember = num_to_remember, power = power, print_error = print_error)
    m_changes = money_growth(cur_tickers, UPPER, LOWER, num_to_remember = num_to_remember, print_error = print_error)[-1]
    #print(normal)

    daily_capital_norm = []
    for capital in list(zip(*list(normal[2].values()))): daily_capital_norm.append(sum(capital))
    daily_capital_increases_norm = []
    for i in range(1,len(daily_capital_norm)): daily_capital_increases_norm.append(daily_capital_norm[i]/daily_capital_norm[i-1] - 1)
    daily_capital_alg = []
    for capital in list(zip(*list(alg[2].values()))): daily_capital_alg.append(sum(capital))
    daily_capital_increases_alg = []
    for i in range(1,len(daily_capital_alg)): daily_capital_increases_alg.append(daily_capital_alg[i]/daily_capital_alg[i-1] - 1)
    stds = [np.std(daily_capital_increases_norm) * 100,np.std(daily_capital_increases_alg) * 100]

    normal = normal[0]
    alg = alg[0]
    totals = [sum(list(normal.values())),sum(list(alg.values()))]

    # implement logging
    better = 0
    worse = 0
    same = 0
    for i in range(len(daily_capital_increases_norm)):
        if (daily_capital_increases_alg[i] > daily_capital_increases_norm[i]):
            better += 1
        elif (daily_capital_increases_alg[i] < daily_capital_increases_norm[i]):
            worse += 1
        else:
            same += 1
    #print(f'better: {better}\nworse: {worse}\nbetter {better/(better+worse)}% of the time')


    price_risk_ratio = [totals[0]/stds[0],totals[1]/stds[1]]

    return (totals,stds,price_risk_ratio,[better,same,worse])


def graph():
    all_tickers = list(tickers);
    disposable_tickers = list(all_tickers)
    cur_tickers = []
    for i in range(len(all_tickers)):
        cur_tickers.append(disposable_tickers.pop(0))
        companies = []
        types = []

        sum_monthly_changes = [0 for i in range(13)]



        totals,stds,price_risk_ratio,diagnostics = calculate_values(cur_tickers);



        plt.figure(figsize=(9,6))
        sns.barplot(x=["normal","alg"], y=totals)
        plt.axhline(y=100, color="black")
        plt.xlabel("Companies")
        plt.ylabel("Total $ Afterwards")
        plt.title(f"Normal vs Algorithm Effectiveness on Stock Market {THE_YEAR}")
        plt.show()
        print(f'Total $ afterwards: \n\tnormal: {totals[0]}\n\talg: {totals[1]}\n\tdifference between alg and norm: {totals[1]-totals[0]}\n{"alg" if totals[1] > totals[0] else "norm"} is {totals[1]/totals[0]*100-100}% better (higher)\n')

        plt.figure(figsize=(9,6))
        sns.barplot(x=["normal","alg"], y=stds)
        plt.xlabel("Companies")
        plt.ylabel("standard deviation of price increase")
        plt.title(f"Normal vs Algorithm Effectiveness on Stock Market {THE_YEAR}")
        plt.show()
        print(f'Risk (standard deviation): \n\tnormal: {stds[0]}\n\talg: {stds[1]}\n\tdifference between alg and norm: {stds[1]-stds[0]}\n{"alg" if stds[1] > stds[0] else "norm"} is {stds[1]/stds[0]*100-100}% worse (higher)\n')

        plt.figure(figsize=(9,6))
        sns.barplot(x=["normal","alg"], y=price_risk_ratio)
        plt.xlabel("Companies")
        plt.ylabel("price-risk ratio")
        plt.title(f"Normal vs Algorithm Effectiveness on Stock Market {THE_YEAR}")
        plt.show()
        print(f'Price to risk ratio (higher -> better): \n\tnormal: {price_risk_ratio[0]}\n\talg: {price_risk_ratio[1]}\n\tdifference between alg and norm: {price_risk_ratio[1]-price_risk_ratio[0]}\n{"alg" if price_risk_ratio[1] > price_risk_ratio[0] else "norm"} is {price_risk_ratio[1]/price_risk_ratio[0]*100-100}% better (higher)\n')

        TEST = cur_tickers;

        portfolio, stock_values, investment_log, the_dates, monthly_changes, percent_investment_log = money_growth(TEST,UPPER, LOWER)

        new_x = [i for i in range(len(the_dates))]
        date2x = {the_dates[i]: i for i in new_x}

        fig, axis = plt.subplots(1,1)

        for stock in cur_tickers:
            axis.plot(new_x, stock_values[stock], label=f"{stock} price")
            #axis.plot(new_x, investment_log[stock], label=f"{stock} owned")
        axis.set_title('investment and hold values')
        # for i in range(len(times_adj)):
        #   if i < len(c_adj): plt.axvline(x=date2x[times_adj[i]], linestyle='--', color=c_adj[i], linewidth=0.5)

        plt.xlabel("Days since start of investment")
        plt.ylabel("$(USD)")
        plt.title(f"Algorithm Results for {TEST} during {THE_YEAR}")
        axis.legend()
        plt.show()

        for stock in cur_tickers:
            plt.plot(range(len(percent_investment_log[stock])),percent_investment_log[stock],label = "% invested in "+stock)
        plt.legend()
        plt.title('split')
        plt.tight_layout()
        plt.show()

        print(sum(list(portfolio.values())))
graph()

tickers = ["BTC-USD", "ETH-USD", "ADA-USD", "XRP-USD", "SOL-USD", "BNB-USD", "DOGE-USD"]#,'NONE']
all_totals = [[],[]]
all_stds = [[],[]]
all_price_risk_ratios = [[],[]]
better_percent_with_none = [list() for i in range(len(tickers))]
better_percent_without_none = [list() for i in range(len(tickers))]
better_or_same_percent_with_none = [list() for i in range(len(tickers))]
better_or_same_percent_without_none = [list() for i in range(len(tickers))]
diagnostics_with_none = [list() for i in range(len(tickers))]
diagnostics_without_none = [list() for i in range(len(tickers))]

data_by_num_with_none = list([[],[],[]] for i in range(len(tickers)))
data_by_num_without_none = list([[],[],[]] for i in range(len(tickers)))


for permutation in permute(tickers)[1:]:
    permutation = permutation.copy()
    totals,stds,price_risk_ratio,diagnostics = calculate_values(permutation,print_error = False);
    data_by_num_without_none[len(permutation)-1][0].append(totals)
    data_by_num_without_none[len(permutation)-1][1].append(stds)
    data_by_num_without_none[len(permutation)-1][2].append(price_risk_ratio)
    better_percent_without_none[len(permutation)-1].append(diagnostics[0]/sum(diagnostics))
    better_or_same_percent_without_none[len(permutation)-1].append((diagnostics[0]+diagnostics[1])/sum(diagnostics))
    diagnostics_without_none[len(permutation)-1].append(diagnostics)
    all_totals[0].append(totals[0])
    all_totals[1].append(totals[1])
    all_stds[0].append(stds[0])
    all_stds[1].append(stds[1])
    all_price_risk_ratios[0].append(price_risk_ratio[0])
    all_price_risk_ratios[1].append(price_risk_ratio[1])



# for permutation in permute(tickers)[1:]:
#     permutation = permutation.copy()
#     permutation += ["NONE"]
#     totals,stds,price_risk_ratio,diagnostics = calculate_values(permutation,print_error = False);
#     data_by_num_with_none[len(permutation)-2][0].append(totals)
#     data_by_num_with_none[len(permutation)-2][1].append(stds)
#     data_by_num_with_none[len(permutation)-2][2].append(price_risk_ratio)
#     better_percent_with_none[len(permutation)-2].append(diagnostics[0]/sum(diagnostics))
#     better_or_same_percent_with_none[len(permutation)-2].append((diagnostics[0]+diagnostics[1])/sum(diagnostics))
#     diagnostics_with_none[len(permutation)-2].append(diagnostics)
#     all_totals[0].append(totals[0])
#     all_totals[1].append(totals[1])
#     all_stds[0].append(stds[0])
#     all_stds[1].append(stds[1])
#     all_price_risk_ratios[0].append(price_risk_ratio[0])
#     all_price_risk_ratios[1].append(price_risk_ratio[1])

def graph_permutation_experiment(data_by_num):
    fit, axes = plt.subplots(3,2)
    plt.subplots_adjust(wspace=0.5, hspace=1.5)
    for i, title in enumerate(["return","risk","return/risk"]):
        all_bars = []

        bars = {}
        for j, data in enumerate(data_by_num):
            bars[j+1] = np.mean(list(bundle[0] for bundle in data[i]))
            if i == 0:
                bars[j+1] -= 100

        sns.barplot(data = bars,ax=axes[i,0])
        x = range(len(bars))
        y = list(bars.values())
        m, b = np.polyfit(x, y, 1)
        #axes[i,0].plot(x, m*x + b, color='green', linestyle='--', linewidth=2, label='Line of Best Fit')
        all_bars += list(bars.values())

        bars = {}
        for j, data in enumerate(data_by_num):
            bars[j+1] = np.mean(list(bundle[1] for bundle in data[i]))
            if i == 0:
                bars[j+1] -= 100

        sns.barplot(data = bars,ax=axes[i,1])
        x = range(len(bars))
        y = list(bars.values())
        m, b = np.polyfit(x, y, 1)
        #axes[i,1].plot(x, m*x + b, color='green', linestyle='--', linewidth=2, label='Line of Best Fit')
        all_bars += list(bars.values())

        axes[i,0].set_title("b&h "+title)
        axes[i,1].set_title("alg "+title)

        axes[i, 0].set_ylim(0,max(all_bars))
        axes[i, 0].set_xlabel("Stock Permutation")
        axes[i, 0].set_ylabel(title)
        #axes[i, 0].yaxis.set_major_locator(MaxNLocator(3))

        axes[i, 1].set_ylim(0,max(all_bars))
        axes[i, 1].set_xlabel("Stock Permutation")
        axes[i, 1].set_ylabel(title)
        #axes[i, 1].yaxis.set_major_locator(MaxNLocator(3))



    plt.show()
graph_permutation_experiment(data_by_num_without_none)
print()
# graph_permutation_experiment(data_by_num_with_none)
# print(better_percent_with_none)
# sns.barplot(dict(zip(list(range(1,11)),list(np.mean(l) for l in better_percent_with_none))))
# plt.show()
# print();
sns.barplot(dict(zip(list(range(1,11)),list(np.mean(l) for l in better_percent_without_none))))
plt.show();
print();
# sns.barplot(dict(zip(list(range(1,11)),list(np.mean(l) for l in better_or_same_percent_with_none))))
# plt.show()
# print();
sns.barplot(dict(zip(list(range(1,11)),list(np.mean(l) for l in better_or_same_percent_without_none))))
plt.show();
print();

# print(diagnostics_with_none)
print(diagnostics_without_none)

def transpose_list_of_lists(data):
    return list(map(list, zip(*data)))



def format_data_for_barplot(l):
    categories = range(1, len(l) + 1)  # Index + 1 for readability
    subcategories = ["Outpreforms", "Same Decision", "Underpreforms"]  # Hues

    data = {
        "Index": [],
        "Category": [],
        "Value": []
    }

    for i, cat in enumerate(categories):
        data["Index"].extend([cat] * 3)
        data["Category"].extend(subcategories)
        values = []
        for j in range(3):
            tpe = []
            for tpl in l[i]:
                tpe.append(tpl[j]/sum(tpl))
            values.append(np.mean(tpe))
        data["Value"].extend(values)

    return data

diagnostics_with_none_formatted = format_data_for_barplot(diagnostics_with_none)
print(diagnostics_with_none_formatted)
diagnostics_without_none_formatted = format_data_for_barplot(diagnostics_without_none)
print(diagnostics_without_none_formatted)
sns.barplot(data=diagnostics_without_none_formatted,x="Index", y="Value", hue="Category")
plt.show();
print();

sentiment_bars = {}
b_and_h_bars = {}
for i in range(19,25):
    global THE_YEAR
    global end_week
    global dat2positive
    global dat2number
    global all_dates
    global norm
    global x
    global bound
    THE_YEAR = 2000 + i
    end_week = simulate_investment_weekly(stock_data, THE_YEAR)
    dat2positive, dat2number = get_positive_number(end_week, THE_YEAR)
    all_dates = list(end_week.keys())

    data = calculate_values(tickers)
    sentiment_bars[THE_YEAR] = list( item[1] for item in data )
    b_and_h_bars[THE_YEAR] = list( item[0] for item in data )

'''

RESULTS ARNAV

2021:
TOTAL ALG: $1233.6352802604656
TOTAL $50 B&H: $1213.0537801661524
TOTAL $100 B&H: $1426.1075603323043
RISK ALG: 6.002347542768573
RISK $50 B&H: 6.048933200236336
RISK $100 B&H: 11.267872601941605




2022:
TOTAL ALG: $832.6383326556089
TOTAL $50 B&H: $771.090330568004
TOTAL $100 B&H: $542.1806611360079
RISK ALG: 9.191769925360667
RISK $50 B&H: 8.39339978138562
RISK $100 B&H: 21.080720459196296


2023:
TOTAL ALG: $1580.3750933159704
TOTAL $50 B&H: $1467.6714311253436
TOTAL $100 B&H: $1935.3428622506867
RISK ALG: 7.455587224541349
RISK $50 B&H: 7.29819547840902
RISK $100 B&H: 12.312006176057315
'''

sentiment_return_bars = {}
sentiment_risk_bars = {}
b_and_h_return_bars = {}
b_and_h_risk_bars = {}
imported_bars_return = {2019:0, 2020:0, 2021: 23.36352802604656,
2022: (83.6383326556089 - 100),
2023: 58.03750933159704,
2024: 0}

imported_bars_risk = {2019: 0, 2020: 0, 2021: 0.61,
2022: 0.92,
2023: 0.79,
2024: 0}



for (key, value) in sentiment_bars.items():
    sentiment_return_bars[key] = value[0] - 100
    sentiment_risk_bars[key] = value[1]

for (key, value) in b_and_h_bars.items():
    b_and_h_return_bars[key] = value[0] - 100
    b_and_h_risk_bars[key] = value[1]

print (sentiment_return_bars)
print (b_and_h_return_bars)


data = {'Year': list(range(2019,2025)) * 2,
        'Return (Percent Change)':  list(sentiment_return_bars.values()) + list(b_and_h_return_bars.values()),
        'Risk (Standard Deviation of Daily Percent Return)':  list(sentiment_risk_bars.values()) + list(b_and_h_risk_bars.values()),
        'Category': ['Sentiment'] * int(len(sentiment_return_bars)) + ['B&H'] * int(len(b_and_h_return_bars))
        }

print(data)

df = pd.DataFrame(data)

# Create the return barplot
sns.barplot(x='Year', y='Return (Percent Change)', hue='Category', data=df)
plt.show()


# Create the risk barplot
sns.barplot(x='Year', y='Risk (Standard Deviation of Daily Percent Return)', hue='Category', data=df)
plt.show()

'''
WRITE ANALYSIS HERE (in new file)
'''

GRID_SIZE = 20
STEP = 1

def graph_input_output(year):
    global THE_YEAR
    global end_week
    global dat2positive
    global dat2number
    global all_dates
    global norm
    global x
    global bound
    THE_YEAR = year
    end_week = simulate_investment_weekly(stock_data, THE_YEAR)
    # print(end_week)
    dat2positive, dat2number = get_positive_number(end_week, THE_YEAR)
    all_dates = list(end_week.keys())

    diff = np.zeros((int(GRID_SIZE/STEP),int(GRID_SIZE/STEP)));
    for i in range(1,GRID_SIZE,STEP):
        for j in range(1,GRID_SIZE,STEP):
            totals = calculate_values(tickers, 0, 0, i, j)[0]
            diff[int(i/STEP),int(j/STEP)] = totals[1] - totals[0]
    # print(diff)

    plt.figure(figsize=(20, 16))
    sns.heatmap(diff, annot=True, cmap="viridis", fmt=".2f",
                cbar_kws={'label': 'Difference between multi-stock algorithm and Buy and Hold (dollars)'})
    plt.xlabel("Days of Sentiment")
    plt.ylabel("Powesr")
    plt.title("Difference in return between algorithm and b&h with respect to power and cache size")
    plt.show()

    diff = np.zeros((int(GRID_SIZE/STEP),int(GRID_SIZE/STEP)));
    for i in range(0,GRID_SIZE,STEP):
        for j in range(0,GRID_SIZE,STEP):
            totals = calculate_values(tickers, i, -j, 1)[0]
            diff[int(i/STEP),int(j/STEP)] = totals[1] - totals[0]
    # print(diff)

    plt.figure(figsize=(20, 16))
    sns.heatmap(diff, annot=True, cmap="viridis", fmt=".2f",
                cbar_kws={'label': 'Difference between multi-stock algorithm and Buy and Hold (dollars)'})
    plt.xlabel("Upper Bound Size")
    plt.ylabel("Lower Bound Size")
    plt.title("Difference in return between algorithm and b&h with respect to bounds")
    plt.show()

print("GRAPHS FOR 2021")
graph_input_output(2021)


print("GRAPHS FOR 2022")
graph_input_output(2022)


print("GRAPHS FOR 2023")
graph_input_output(2023)